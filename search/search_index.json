{"config":{"indexing":"full","lang":["en","pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;"},"docs":[{"location":"","text":"M690B Wiki This Wiki contains the documentation for preparing, testing and conducting indoor/outdoor missions using the M690B drone. Additionally, the procedures used and the results obtained in the FIREPUMA and CAPTURE missions will also be documented. 1 / 5 2 / 5 3 / 5 4 / 5 5 / 5 \u276e \u276f","title":"Introduction"},{"location":"#m690b-wiki","text":"This Wiki contains the documentation for preparing, testing and conducting indoor/outdoor missions using the M690B drone. Additionally, the procedures used and the results obtained in the FIREPUMA and CAPTURE missions will also be documented. 1 / 5 2 / 5 3 / 5 4 / 5 5 / 5 \u276e \u276f","title":"M690B Wiki"},{"location":"known_issues/","text":"Known issues OS not booting into GUI Sometimes when booting the onboard computer with a monitor and peripherals attached, the OS does not boot into the GUI but is still accessible through SSH. It was found that running the command sudo systemctl set-default graphical.target and rebooting seems to resolve this issue.","title":"Known Issues"},{"location":"known_issues/#known-issues","text":"","title":"Known issues"},{"location":"known_issues/#os-not-booting-into-gui","text":"Sometimes when booting the onboard computer with a monitor and peripherals attached, the OS does not boot into the GUI but is still accessible through SSH. It was found that running the command sudo systemctl set-default graphical.target and rebooting seems to resolve this issue.","title":"OS not booting into GUI"},{"location":"roadmap/","text":"Roadmap Verify drone instrumentation: Install OS - Jetpack 5 Install ROS and setup workspace Setup the VRPN ROS package Setup the MAVROS package Verify communication between MAVROS and the Pixhawk Install the ROS control stack Verify communication between the ROS nodes and the Pixhawk Setup and test QGroundControl Test QGC with the telemetry radio Calibrate the flight controller Verify drone sanity flight (manual mode, at ISR-Tagus and/or Cybaer-lab): Gazebo simulation with the mission algorithm running on the onboard computer Indoor power on (no blades) Outdoor power on with blades (see if Pixhawk controller gains need to be changed) Range test Manual flight with data acquisition and ground monitoring Dummy weight lifting tests (see if Pixhawk controller gains need to be changed) (no onboard computer installed) - create thrust curve. PixHawk autonomous mission mode trials: Takeoff, hover, land (see if controller gains need to be changed) Typical mission for the controllers to be tested Off-board controller(s) running but not controlling vehicle (collected data used afterwards to see response of off-board controllers) First off-board waypoint simple controller, no MPC, Guassian and/or GM; Online off-board MPC mission for PirePuma algorithms; Repeat previous trials with improved missions or algorithms.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Verify drone instrumentation: Install OS - Jetpack 5 Install ROS and setup workspace Setup the VRPN ROS package Setup the MAVROS package Verify communication between MAVROS and the Pixhawk Install the ROS control stack Verify communication between the ROS nodes and the Pixhawk Setup and test QGroundControl Test QGC with the telemetry radio Calibrate the flight controller Verify drone sanity flight (manual mode, at ISR-Tagus and/or Cybaer-lab): Gazebo simulation with the mission algorithm running on the onboard computer Indoor power on (no blades) Outdoor power on with blades (see if Pixhawk controller gains need to be changed) Range test Manual flight with data acquisition and ground monitoring Dummy weight lifting tests (see if Pixhawk controller gains need to be changed) (no onboard computer installed) - create thrust curve. PixHawk autonomous mission mode trials: Takeoff, hover, land (see if controller gains need to be changed) Typical mission for the controllers to be tested Off-board controller(s) running but not controlling vehicle (collected data used afterwards to see response of off-board controllers) First off-board waypoint simple controller, no MPC, Guassian and/or GM; Online off-board MPC mission for PirePuma algorithms; Repeat previous trials with improved missions or algorithms.","title":"Roadmap"},{"location":"Hardware%20Setup/","text":"Hardware Setup This section describes the various hardware components of vehicle. Namely, the Onboard Computer , the Flight Computer and the Radio and Receiver .","title":"Hardware Setup"},{"location":"Hardware%20Setup/#hardware-setup","text":"This section describes the various hardware components of vehicle. Namely, the Onboard Computer , the Flight Computer and the Radio and Receiver .","title":"Hardware Setup"},{"location":"Hardware%20Setup/flight_computer/","text":"Flight Computer The flight computer for this vehicle consists of a Holybro Pixhawk 6C board. To communicate with the board, the USB-C port can be used. Alternatively, the TELEM1 port can be used together with an FTDI adapter. In the latter, the documentation shows how to wire the cable between the TELEM1 port and the FTDI adaptor.","title":"Flight Computer"},{"location":"Hardware%20Setup/flight_computer/#flight-computer","text":"The flight computer for this vehicle consists of a Holybro Pixhawk 6C board. To communicate with the board, the USB-C port can be used. Alternatively, the TELEM1 port can be used together with an FTDI adapter. In the latter, the documentation shows how to wire the cable between the TELEM1 port and the FTDI adaptor.","title":"Flight Computer"},{"location":"Hardware%20Setup/onboard_computer/","text":"Onboard Computer The onboard computer for this vehicle consists of an NVIDIA Jetson Xavier NX board which is installed in the Connect Tech Photon carrier board. The specific version of board is the REV G , SN5320 , NGX002 . Additionally, a 1 TB NVMe SSD was installed in the M.2 2280 M-KEY slot in the carrier board. To ensure the use of the SSD is enabled, the onboard DIP switch SW1-2 should be on the ON position. More information regarding the operation of the carrier board and connector location can be found in the carrier board manual .","title":"Onboard Computer"},{"location":"Hardware%20Setup/onboard_computer/#onboard-computer","text":"The onboard computer for this vehicle consists of an NVIDIA Jetson Xavier NX board which is installed in the Connect Tech Photon carrier board. The specific version of board is the REV G , SN5320 , NGX002 . Additionally, a 1 TB NVMe SSD was installed in the M.2 2280 M-KEY slot in the carrier board. To ensure the use of the SSD is enabled, the onboard DIP switch SW1-2 should be on the ON position. More information regarding the operation of the carrier board and connector location can be found in the carrier board manual .","title":"Onboard Computer"},{"location":"Hardware%20Setup/radio_and_receiver/","text":"Radio and Receiver Radio The radio used is the Taranis X9D Plus . The transmitter was binded to the receiver according to the instructions provided by the receiver manufactor and a new model for the M690B was created on the transmitter. The inputs and channel mixer were mapped as following. INPUTS Mapping MIXER Description Thr Thr CH1 Engine Ail Ail CH2 Roll Ele Ele CH3 Pitch Rud Rud CH4 Yaw FMod SE CH5 Flight Mode Offb SB CH6 Offboard Kill SC CH7 Kill SW ARM SD CH8 ARM SW Receiver The receiver used is the FrSky X8R which is connected to the flight computer using the SBUS connection. Instructions to bind the receiver with the transmitter can be found here .","title":"Radio and Receiver"},{"location":"Hardware%20Setup/radio_and_receiver/#radio-and-receiver","text":"","title":"Radio and Receiver"},{"location":"Hardware%20Setup/radio_and_receiver/#radio","text":"The radio used is the Taranis X9D Plus . The transmitter was binded to the receiver according to the instructions provided by the receiver manufactor and a new model for the M690B was created on the transmitter. The inputs and channel mixer were mapped as following. INPUTS Mapping MIXER Description Thr Thr CH1 Engine Ail Ail CH2 Roll Ele Ele CH3 Pitch Rud Rud CH4 Yaw FMod SE CH5 Flight Mode Offb SB CH6 Offboard Kill SC CH7 Kill SW ARM SD CH8 ARM SW","title":"Radio"},{"location":"Hardware%20Setup/radio_and_receiver/#receiver","text":"The receiver used is the FrSky X8R which is connected to the flight computer using the SBUS connection. Instructions to bind the receiver with the transmitter can be found here .","title":"Receiver"},{"location":"Mission%20Logs/","text":"Mission Logs This section contains reports and logs from the missions executed with the M690B drone. These include ulog files from the flight computer, rosbag files from the onboard computer and video footage from the missions. Some useful tools for analysing the logs are: PX4 Flight Review and Plotjuggler .","title":"Mission Logs"},{"location":"Mission%20Logs/#mission-logs","text":"This section contains reports and logs from the missions executed with the M690B drone. These include ulog files from the flight computer, rosbag files from the onboard computer and video footage from the missions. Some useful tools for analysing the logs are: PX4 Flight Review and Plotjuggler .","title":"Mission Logs"},{"location":"Mission%20Logs/05-07-2023/","text":"05-07-2023 In this trial, both drones from IST and NOVA flew for the first time. Only manual flight was tested and the controller gains were tuned. Footage Videos and photos Logs M690B IST Logs from the flight computer Rosbags from the onboard computer M690B NOVA Logs from the flight computer Flight Plan","title":"05-07-2023"},{"location":"Mission%20Logs/05-07-2023/#05-07-2023","text":"In this trial, both drones from IST and NOVA flew for the first time. Only manual flight was tested and the controller gains were tuned.","title":"05-07-2023"},{"location":"Mission%20Logs/05-07-2023/#footage","text":"Videos and photos","title":"Footage"},{"location":"Mission%20Logs/05-07-2023/#logs","text":"","title":"Logs"},{"location":"Mission%20Logs/05-07-2023/#m690b-ist","text":"Logs from the flight computer Rosbags from the onboard computer","title":"M690B IST"},{"location":"Mission%20Logs/05-07-2023/#m690b-nova","text":"Logs from the flight computer","title":"M690B NOVA"},{"location":"Mission%20Logs/05-07-2023/#flight-plan","text":"","title":"Flight Plan"},{"location":"Mission%20Logs/13-07-2023/","text":"13-07-2023 In this trial, the drone from IST was used in several manual flights in order to adjust the gains of the PID controllers. The test was successful resulting in the drone having a decent reaction to the control inputs. Footage Videos and photos Logs M690B IST Logs from the flight computer Rosbags from the onboard computer M690B NOVA Logs from the flight computer Flight Plan","title":"13-07-2023"},{"location":"Mission%20Logs/13-07-2023/#13-07-2023","text":"In this trial, the drone from IST was used in several manual flights in order to adjust the gains of the PID controllers. The test was successful resulting in the drone having a decent reaction to the control inputs.","title":"13-07-2023"},{"location":"Mission%20Logs/13-07-2023/#footage","text":"Videos and photos","title":"Footage"},{"location":"Mission%20Logs/13-07-2023/#logs","text":"","title":"Logs"},{"location":"Mission%20Logs/13-07-2023/#m690b-ist","text":"Logs from the flight computer Rosbags from the onboard computer","title":"M690B IST"},{"location":"Mission%20Logs/13-07-2023/#m690b-nova","text":"Logs from the flight computer","title":"M690B NOVA"},{"location":"Mission%20Logs/13-07-2023/#flight-plan","text":"","title":"Flight Plan"},{"location":"Mission%20Logs/20-07-2023/","text":"20-07-2023 In this trial, the drone from IST was used in several manual and GPS flights in order to test safety modes based on GPS navigation such as the return-to-launch mode. Tests using different payloads were also conducted, adding 1kg, and 2kg payloads and hovering in Position mode, yet the drone revealed to be near instability when carrying 2kg, for which further PID adjustment is needed, and when landing, it tilted forward and two propellers were damaged. After replacing the propellers, removing the weights, and checking for airworthiness, a basic offboard mode test was conducted, using waypoints describing a square. Footage Videos and photos Logs M690B IST Logs from the flight computer Rosbags from the onboard computer Flight Plan","title":"20-07-2023"},{"location":"Mission%20Logs/20-07-2023/#20-07-2023","text":"In this trial, the drone from IST was used in several manual and GPS flights in order to test safety modes based on GPS navigation such as the return-to-launch mode. Tests using different payloads were also conducted, adding 1kg, and 2kg payloads and hovering in Position mode, yet the drone revealed to be near instability when carrying 2kg, for which further PID adjustment is needed, and when landing, it tilted forward and two propellers were damaged. After replacing the propellers, removing the weights, and checking for airworthiness, a basic offboard mode test was conducted, using waypoints describing a square.","title":"20-07-2023"},{"location":"Mission%20Logs/20-07-2023/#footage","text":"Videos and photos","title":"Footage"},{"location":"Mission%20Logs/20-07-2023/#logs","text":"","title":"Logs"},{"location":"Mission%20Logs/20-07-2023/#m690b-ist","text":"Logs from the flight computer Rosbags from the onboard computer","title":"M690B IST"},{"location":"Mission%20Logs/20-07-2023/#flight-plan","text":"","title":"Flight Plan"},{"location":"Mission%20Logs/27-07-2023/","text":"27-07-2023 In this trial, the drones from IST and NOVA were used in several Manual and GPS flights in order to test basic functionality of the new NVidia Orin Nano Board on the NOVA drone, and also acquire data using the Intel RealSense D455 onboard the IST drone. As it was too windy, further offboard mode trials were postponed. Footage Videos and photos Logs M690B IST Logs from the flight computer Rosbags from the onboard computer M690B NOVA Logs from the flight computer Rosbags from the onboard computer Flight Plan","title":"27-07-2023"},{"location":"Mission%20Logs/27-07-2023/#27-07-2023","text":"In this trial, the drones from IST and NOVA were used in several Manual and GPS flights in order to test basic functionality of the new NVidia Orin Nano Board on the NOVA drone, and also acquire data using the Intel RealSense D455 onboard the IST drone. As it was too windy, further offboard mode trials were postponed.","title":"27-07-2023"},{"location":"Mission%20Logs/27-07-2023/#footage","text":"Videos and photos","title":"Footage"},{"location":"Mission%20Logs/27-07-2023/#logs","text":"","title":"Logs"},{"location":"Mission%20Logs/27-07-2023/#m690b-ist","text":"Logs from the flight computer Rosbags from the onboard computer","title":"M690B IST"},{"location":"Mission%20Logs/27-07-2023/#m690b-nova","text":"Logs from the flight computer Rosbags from the onboard computer","title":"M690B NOVA"},{"location":"Mission%20Logs/27-07-2023/#flight-plan","text":"","title":"Flight Plan"},{"location":"Mission%20Logs/28-07-2023/","text":"28-07-2023 In this trial, the drone from NOVA was used in several GPS flights in order to acquire data using the Intel RealSense D455 onboard the NOVA drone as well as test basic and regular waypoint-based offboard missions. It was still too windy, yet the trials were considered to be a success. Footage Videos and photos Logs M690B NOVA Logs from the flight computer Rosbags from the onboard computer Flight Plan","title":"28-07-2023"},{"location":"Mission%20Logs/28-07-2023/#28-07-2023","text":"In this trial, the drone from NOVA was used in several GPS flights in order to acquire data using the Intel RealSense D455 onboard the NOVA drone as well as test basic and regular waypoint-based offboard missions. It was still too windy, yet the trials were considered to be a success.","title":"28-07-2023"},{"location":"Mission%20Logs/28-07-2023/#footage","text":"Videos and photos","title":"Footage"},{"location":"Mission%20Logs/28-07-2023/#logs","text":"","title":"Logs"},{"location":"Mission%20Logs/28-07-2023/#m690b-nova","text":"Logs from the flight computer Rosbags from the onboard computer","title":"M690B NOVA"},{"location":"Mission%20Logs/28-07-2023/#flight-plan","text":"","title":"Flight Plan"},{"location":"Software%20Setup/","text":"Software Setup This section describes in detail all the procedures used to install and configure the software that runs on the vehicle's hardware components. Namely, the OS and ROS installation on the onboard computer , the VRPN and MAVROS Setup , the PX4 Configuration Checklist , the Drone Control Stack Setup and some Usefull Packages . graph LR A(MOCAP) -- UDP --> B(ROUTER) B -- UDP --> C(vrpn_client_ros) subgraph Onboard Computer C -- ROSTOPIC --- D(MAVROS) G(\"Main Algorithm (Mission)\") -- ROSTOPIC --- D end subgraph Flight Computer D -- MAVLINK --- E(PX4-Autopilot) end B -- \"UDP (gcs_url)\" --- D subgraph Companion Computer F(QGroundControl) end F -- \"UDP (fcu_url)\" --- B F-. \"TELEM RADIO\" .- E","title":"Software Setup"},{"location":"Software%20Setup/#software-setup","text":"This section describes in detail all the procedures used to install and configure the software that runs on the vehicle's hardware components. Namely, the OS and ROS installation on the onboard computer , the VRPN and MAVROS Setup , the PX4 Configuration Checklist , the Drone Control Stack Setup and some Usefull Packages . graph LR A(MOCAP) -- UDP --> B(ROUTER) B -- UDP --> C(vrpn_client_ros) subgraph Onboard Computer C -- ROSTOPIC --- D(MAVROS) G(\"Main Algorithm (Mission)\") -- ROSTOPIC --- D end subgraph Flight Computer D -- MAVLINK --- E(PX4-Autopilot) end B -- \"UDP (gcs_url)\" --- D subgraph Companion Computer F(QGroundControl) end F -- \"UDP (fcu_url)\" --- B F-. \"TELEM RADIO\" .- E","title":"Software Setup"},{"location":"Software%20Setup/drone_control_stack/","text":"Drone Control Stack Setup This section describes the steps followed to install the drone control stack on the onboard computer. This stack is composed of ROS packages which allow the vehicle to be controlled from ROS nodes using the available cpp UAV class. It should be noted that the steps described include everything that is needed to run simulations in adition to controlling the real drone. Environment Setup Before installing the ROS packages, it is necessary to create a workspace and install the PX4 firmware (only used for simulations). Creating a catkin workspace mkdir ~/uav/uav_ws/src cd ~/uav/uav_ws catkin_make Installing the PX4 firmware cd ~/uav git clone --recursive https://github.com/PX4/PX4-Autopilot.git cd PX4-Autopilot git fetch --all --tags git checkout v1.12.3 -b latest git submodule update --init --recursive make px4_sitl gazebo Note While installing the PX4 firmware, some missing packages might need to be installed with pip. If pip is not available it can be installed with sudo apt install python3-pip . In order not to pollute the bashrc profile, a script was created to load the needed environment variables cd ~/uav touch setup.bash Contents of the setup.bash file source ~/uav/uav_ws/devel/setup.bash export CATKIN_WORKSPACE = ~/uav/uav_ws export GAZEBO_PLUGIN_PATH = $GAZEBO_PLUGIN_PATH :/home/jetson/uav/PX4-Autopilot/build_gazebo export GAZEBO_MODEL_PATH = $GAZEBO_MODEL_PATH :/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo/models export LD_LIBRARY_PATH = $LD_LIBRARY_PATH :/home/jetson/uav/PX4-Autopilot/build_gazebo export ROS_PACKAGE_PATH = $ROS_PACKAGE_PATH :/home/jetson/uav/PX4-Autopilot:/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo source /home/jetson/uav/PX4-Autopilot/Tools/setup_gazebo.bash /home/jetson/uav/PX4-Autopilot /home/jetson/uav/PX4-Autopilot/build/px4_sitl_default Control Stack Overview Now that the environment is prepared, the code stack can be installed inside the created workspace. Below is a tree view of all the packages included in the stack. The packages listed here are available in this repository . src/ \u251c\u2500\u2500 drone_bringup \u251c\u2500\u2500 drone_gazebo \u2502 \u251c\u2500\u2500 drone_description \u2502 \u2514\u2500\u2500 drone_worlds \u251c\u2500\u2500 drone_launch \u2514\u2500\u2500 drone_library \u251c\u2500\u2500 drone_gimmicks_library \u251c\u2500\u2500 drone_utils_cpp \u2514\u2500\u2500 mavros_cpp Simulation flow graph TD A(<b>simulator_bringup.launch</b> <br> drone_launch) --> B(<b>vehicle_bringup.launch</b> <br> drone_launch); A --> C(<b>empty_world.launch</b> <br> gazebo_ros); A -. simulator_bringup_rviz.launch .-> G(<b>rviz</b> <br> rviz); B --> D(<b>single_vehicle_spawn.launch</b> <br> drone_launch); B --> E(<b>px4.launch</b> <br> mavros); B --> F(<b>drone_sim.launch</b> <br> drone_bringup); Real mission flow graph TD A(<b>real_bringup_rviz.launch</b> <br> drone_launch) --> B(<b>px4.launch</b> <br> mavros); A --> C(<b>drone_sim.launch</b> <br> drone_bringup); A --> G(<b>rviz</b> <br> rviz); ROS Packages Overview drone_bringup The drone_sim.launch file loads the vehicle and main algorithm parameters and calls the ROS node that has the mission to be carried out. src/drone_bringup/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 simulation \u2502 \u2514\u2500\u2500 iris \u2502 \u2514\u2500\u2500 config.yaml \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 drone_sim.launch \u2514\u2500\u2500 package.xml drone_description The drone_description package contains the Gazebo models for the vehicles used. src/drone_gazebo/drone_description/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 models \u2502 \u2514\u2500\u2500 iris \u2502 \u251c\u2500\u2500 iris.sdf.jinja \u2502 \u251c\u2500\u2500 iris.urdf \u2502 \u251c\u2500\u2500 meshes \u2502 \u2502 \u251c\u2500\u2500 iris_prop_ccw.dae \u2502 \u2502 \u251c\u2500\u2500 iris_prop_cw.dae \u2502 \u2502 \u2514\u2500\u2500 iris.stl \u2502 \u2514\u2500\u2500 model.config \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 scripts \u251c\u2500\u2500 jinja_gen.py \u251c\u2500\u2500 names.py \u251c\u2500\u2500 schema_download.bash \u251c\u2500\u2500 substitution_args.py \u2514\u2500\u2500 validate_sdf.bash drone_worlds The drone_worlds package contains the world files that can be used during simulations in Gzaebo . src/drone_gazebo/drone_worlds/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 worlds \u251c\u2500\u2500 baylands.world \u251c\u2500\u2500 boat.world \u251c\u2500\u2500 empty.world \u251c\u2500\u2500 hippocampus.world \u251c\u2500\u2500 hitl_iris.world \u251c\u2500\u2500 hitl_standard_vtol.world \u251c\u2500\u2500 iris_irlock.world \u251c\u2500\u2500 ksql_airport.world \u251c\u2500\u2500 mcmillan_airfield.world \u251c\u2500\u2500 ocean.world \u251c\u2500\u2500 sonoma_raceway.world \u251c\u2500\u2500 typhoon_h480.world \u251c\u2500\u2500 uuv_bluerov2_heavy.world \u251c\u2500\u2500 uuv_hippocampus.world \u251c\u2500\u2500 warehouse.world \u251c\u2500\u2500 windy.world \u2514\u2500\u2500 yosemite.world drone_launch The drone_launch package contains several launch files that are used to run simulations and to run missions with the real drone. src/drone_launch/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 launch \u2502 \u251c\u2500\u2500 real_bringup_rviz.launch \u2502 \u251c\u2500\u2500 rvizcfg.rviz \u2502 \u251c\u2500\u2500 simulator_bringup.launch \u2502 \u251c\u2500\u2500 simulator_bringup_rviz.launch \u2502 \u251c\u2500\u2500 single_vehicle_spawn.launch \u2502 \u2514\u2500\u2500 vehicle_bringup.launch \u2514\u2500\u2500 package.xml drone_gimmicks_library The drone_gimmicks_library package contains some useful macros to reduce the complexity of some common ROS operations like getting parameters. src/drone_library/drone_gimmicks_library/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 drone_gimmicks_library \u2502 \u2514\u2500\u2500 DroneGimmicks.h \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 src \u2514\u2500\u2500 DroneGimmicks.cpp drone_utils_cpp The drone_utils_cpp package contains some useful functions while working with drones, like converting between different coordinate frames and normalizing thrust values. src/drone_library/drone_utils_cpp/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 doc \u2502 \u2514\u2500\u2500 README.md \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 drone_utils_cpp \u2502 \u251c\u2500\u2500 DroneInfo.h \u2502 \u251c\u2500\u2500 DroneStatus.h \u2502 \u2514\u2500\u2500 Utils.h \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 src \u2514\u2500\u2500 Utils.cpp mavros_cpp The mavros_cpp package contains the main class ( UAV ) which is used to control the drone as well as to get telemetry data. src/drone_library/mavros_cpp/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 doc \u2502 \u2514\u2500\u2500 README.md \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 mavros_cpp \u2502 \u251c\u2500\u2500 Actuators.h \u2502 \u251c\u2500\u2500 EKF.h \u2502 \u251c\u2500\u2500 Sensors.h \u2502 \u2514\u2500\u2500 UAV.h \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 src \u251c\u2500\u2500 offboard.cpp \u251c\u2500\u2500 telemetry.cpp \u2514\u2500\u2500 UAV.cpp Simulation example After installing the code stack the provided lissajous example package can be executed in simulation. The drone_sim.launch file in the drone_bringup package should contain a call to the lissajous ROS node like so - <node pkg=\"lissajous\" type=\"lissajous_node\" name=\"lissajous\" respawn=\"false\" output=\"screen\"/> . Build the workspace cd ~/uav/uav_ws catkin_make Source the provided bash script cd ~/uav source setup.bash Run the simulation roslaunch drone_launch simulator_bringup.launch","title":"Drone Control Stack Setup"},{"location":"Software%20Setup/drone_control_stack/#drone-control-stack-setup","text":"This section describes the steps followed to install the drone control stack on the onboard computer. This stack is composed of ROS packages which allow the vehicle to be controlled from ROS nodes using the available cpp UAV class. It should be noted that the steps described include everything that is needed to run simulations in adition to controlling the real drone.","title":"Drone Control Stack Setup"},{"location":"Software%20Setup/drone_control_stack/#environment-setup","text":"Before installing the ROS packages, it is necessary to create a workspace and install the PX4 firmware (only used for simulations). Creating a catkin workspace mkdir ~/uav/uav_ws/src cd ~/uav/uav_ws catkin_make Installing the PX4 firmware cd ~/uav git clone --recursive https://github.com/PX4/PX4-Autopilot.git cd PX4-Autopilot git fetch --all --tags git checkout v1.12.3 -b latest git submodule update --init --recursive make px4_sitl gazebo Note While installing the PX4 firmware, some missing packages might need to be installed with pip. If pip is not available it can be installed with sudo apt install python3-pip . In order not to pollute the bashrc profile, a script was created to load the needed environment variables cd ~/uav touch setup.bash Contents of the setup.bash file source ~/uav/uav_ws/devel/setup.bash export CATKIN_WORKSPACE = ~/uav/uav_ws export GAZEBO_PLUGIN_PATH = $GAZEBO_PLUGIN_PATH :/home/jetson/uav/PX4-Autopilot/build_gazebo export GAZEBO_MODEL_PATH = $GAZEBO_MODEL_PATH :/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo/models export LD_LIBRARY_PATH = $LD_LIBRARY_PATH :/home/jetson/uav/PX4-Autopilot/build_gazebo export ROS_PACKAGE_PATH = $ROS_PACKAGE_PATH :/home/jetson/uav/PX4-Autopilot:/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo source /home/jetson/uav/PX4-Autopilot/Tools/setup_gazebo.bash /home/jetson/uav/PX4-Autopilot /home/jetson/uav/PX4-Autopilot/build/px4_sitl_default","title":"Environment Setup"},{"location":"Software%20Setup/drone_control_stack/#control-stack-overview","text":"Now that the environment is prepared, the code stack can be installed inside the created workspace. Below is a tree view of all the packages included in the stack. The packages listed here are available in this repository . src/ \u251c\u2500\u2500 drone_bringup \u251c\u2500\u2500 drone_gazebo \u2502 \u251c\u2500\u2500 drone_description \u2502 \u2514\u2500\u2500 drone_worlds \u251c\u2500\u2500 drone_launch \u2514\u2500\u2500 drone_library \u251c\u2500\u2500 drone_gimmicks_library \u251c\u2500\u2500 drone_utils_cpp \u2514\u2500\u2500 mavros_cpp","title":"Control Stack Overview"},{"location":"Software%20Setup/drone_control_stack/#simulation-flow","text":"graph TD A(<b>simulator_bringup.launch</b> <br> drone_launch) --> B(<b>vehicle_bringup.launch</b> <br> drone_launch); A --> C(<b>empty_world.launch</b> <br> gazebo_ros); A -. simulator_bringup_rviz.launch .-> G(<b>rviz</b> <br> rviz); B --> D(<b>single_vehicle_spawn.launch</b> <br> drone_launch); B --> E(<b>px4.launch</b> <br> mavros); B --> F(<b>drone_sim.launch</b> <br> drone_bringup);","title":"Simulation flow"},{"location":"Software%20Setup/drone_control_stack/#real-mission-flow","text":"graph TD A(<b>real_bringup_rviz.launch</b> <br> drone_launch) --> B(<b>px4.launch</b> <br> mavros); A --> C(<b>drone_sim.launch</b> <br> drone_bringup); A --> G(<b>rviz</b> <br> rviz);","title":"Real mission flow"},{"location":"Software%20Setup/drone_control_stack/#ros-packages-overview","text":"","title":"ROS Packages Overview"},{"location":"Software%20Setup/drone_control_stack/#drone_bringup","text":"The drone_sim.launch file loads the vehicle and main algorithm parameters and calls the ROS node that has the mission to be carried out. src/drone_bringup/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 config \u2502 \u2514\u2500\u2500 simulation \u2502 \u2514\u2500\u2500 iris \u2502 \u2514\u2500\u2500 config.yaml \u251c\u2500\u2500 launch \u2502 \u2514\u2500\u2500 drone_sim.launch \u2514\u2500\u2500 package.xml","title":"drone_bringup"},{"location":"Software%20Setup/drone_control_stack/#drone_description","text":"The drone_description package contains the Gazebo models for the vehicles used. src/drone_gazebo/drone_description/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 models \u2502 \u2514\u2500\u2500 iris \u2502 \u251c\u2500\u2500 iris.sdf.jinja \u2502 \u251c\u2500\u2500 iris.urdf \u2502 \u251c\u2500\u2500 meshes \u2502 \u2502 \u251c\u2500\u2500 iris_prop_ccw.dae \u2502 \u2502 \u251c\u2500\u2500 iris_prop_cw.dae \u2502 \u2502 \u2514\u2500\u2500 iris.stl \u2502 \u2514\u2500\u2500 model.config \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 scripts \u251c\u2500\u2500 jinja_gen.py \u251c\u2500\u2500 names.py \u251c\u2500\u2500 schema_download.bash \u251c\u2500\u2500 substitution_args.py \u2514\u2500\u2500 validate_sdf.bash","title":"drone_description"},{"location":"Software%20Setup/drone_control_stack/#drone_worlds","text":"The drone_worlds package contains the world files that can be used during simulations in Gzaebo . src/drone_gazebo/drone_worlds/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 worlds \u251c\u2500\u2500 baylands.world \u251c\u2500\u2500 boat.world \u251c\u2500\u2500 empty.world \u251c\u2500\u2500 hippocampus.world \u251c\u2500\u2500 hitl_iris.world \u251c\u2500\u2500 hitl_standard_vtol.world \u251c\u2500\u2500 iris_irlock.world \u251c\u2500\u2500 ksql_airport.world \u251c\u2500\u2500 mcmillan_airfield.world \u251c\u2500\u2500 ocean.world \u251c\u2500\u2500 sonoma_raceway.world \u251c\u2500\u2500 typhoon_h480.world \u251c\u2500\u2500 uuv_bluerov2_heavy.world \u251c\u2500\u2500 uuv_hippocampus.world \u251c\u2500\u2500 warehouse.world \u251c\u2500\u2500 windy.world \u2514\u2500\u2500 yosemite.world","title":"drone_worlds"},{"location":"Software%20Setup/drone_control_stack/#drone_launch","text":"The drone_launch package contains several launch files that are used to run simulations and to run missions with the real drone. src/drone_launch/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 launch \u2502 \u251c\u2500\u2500 real_bringup_rviz.launch \u2502 \u251c\u2500\u2500 rvizcfg.rviz \u2502 \u251c\u2500\u2500 simulator_bringup.launch \u2502 \u251c\u2500\u2500 simulator_bringup_rviz.launch \u2502 \u251c\u2500\u2500 single_vehicle_spawn.launch \u2502 \u2514\u2500\u2500 vehicle_bringup.launch \u2514\u2500\u2500 package.xml","title":"drone_launch"},{"location":"Software%20Setup/drone_control_stack/#drone_gimmicks_library","text":"The drone_gimmicks_library package contains some useful macros to reduce the complexity of some common ROS operations like getting parameters. src/drone_library/drone_gimmicks_library/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 drone_gimmicks_library \u2502 \u2514\u2500\u2500 DroneGimmicks.h \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 src \u2514\u2500\u2500 DroneGimmicks.cpp","title":"drone_gimmicks_library"},{"location":"Software%20Setup/drone_control_stack/#drone_utils_cpp","text":"The drone_utils_cpp package contains some useful functions while working with drones, like converting between different coordinate frames and normalizing thrust values. src/drone_library/drone_utils_cpp/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 doc \u2502 \u2514\u2500\u2500 README.md \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 drone_utils_cpp \u2502 \u251c\u2500\u2500 DroneInfo.h \u2502 \u251c\u2500\u2500 DroneStatus.h \u2502 \u2514\u2500\u2500 Utils.h \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 src \u2514\u2500\u2500 Utils.cpp","title":"drone_utils_cpp"},{"location":"Software%20Setup/drone_control_stack/#mavros_cpp","text":"The mavros_cpp package contains the main class ( UAV ) which is used to control the drone as well as to get telemetry data. src/drone_library/mavros_cpp/ \u251c\u2500\u2500 CMakeLists.txt \u251c\u2500\u2500 doc \u2502 \u2514\u2500\u2500 README.md \u251c\u2500\u2500 include \u2502 \u2514\u2500\u2500 mavros_cpp \u2502 \u251c\u2500\u2500 Actuators.h \u2502 \u251c\u2500\u2500 EKF.h \u2502 \u251c\u2500\u2500 Sensors.h \u2502 \u2514\u2500\u2500 UAV.h \u251c\u2500\u2500 package.xml \u2514\u2500\u2500 src \u251c\u2500\u2500 offboard.cpp \u251c\u2500\u2500 telemetry.cpp \u2514\u2500\u2500 UAV.cpp","title":"mavros_cpp"},{"location":"Software%20Setup/drone_control_stack/#simulation-example","text":"After installing the code stack the provided lissajous example package can be executed in simulation. The drone_sim.launch file in the drone_bringup package should contain a call to the lissajous ROS node like so - <node pkg=\"lissajous\" type=\"lissajous_node\" name=\"lissajous\" respawn=\"false\" output=\"screen\"/> . Build the workspace cd ~/uav/uav_ws catkin_make Source the provided bash script cd ~/uav source setup.bash Run the simulation roslaunch drone_launch simulator_bringup.launch","title":"Simulation example"},{"location":"Software%20Setup/os_installation/","text":"OS and ROS Installation At the date of writing the most recent version of the JetPack software suppoted by the NVIDIA Jetson Xavier NX module and the Connect Tech Photon carrier board is version 5.1.1 . The following steps describe how to install this JetPack version on the onboard computer. 1. SDK Manager The installation of the operating system must be made using the NVIDIA SDK Manager running on a computer with Ubuntu 18.04 or Ubuntu 20.04 . For reference, the installation was made using a machine with Ubuntu 18.04 and the SDK Manager version 1.9.1.10899 . 2. Board Support Package Installation The carrier board manufactor provides a Board Support Package (BSP) that ensures the correct functioning of the OS with the carrier board. To do this, clear instructions are provided here . During this process, the Jetson Xavier NX modules was selected as the target hardware and the JetPack 5.1.1 (rev. 1) was selected as the target OS. Additionally, the BSP version NX L4T r35.3.1 BSP was downloaded from the manufactor resource center . Given that the SDK Manager version used in the guide is outdated, the images below show the board, OS and target components selection. In step 11 of the guide, the following steps were taken to connect the onboard computer to the machine running the SDK Manager: Connect the Power Cable of the +12V Power Supply into the Barrel Jack; Plug the AC cable on the +12V Power Supply into the wall socket; Press the switch SW2 during 10 seconds to enter forced recovery mode; Press the switch SW2 once to reset the board; Plug in a USB-A to micro USB-B cable from the host machine to the OTG USB port located below the ethernet port on the carrier board; Verify the board is connected by running the lsusb on the host machine. 3. First Boot After the OS installation, the first boot must be made by connecting a monitor and peripherals to the board so as to complete the initial setup and create a user. SSH is not available before creating a user and accepting the license terms. For reference, the username \"jetson\" was created. 4. Booting from the NVMe SSD Now that the OS is installed and working the, the NVMe SSD can be configured as the boot device. To do this it is first necessary to move the root filesystem to the drive. The following steps are according to the rootOnNVMe repository. git clone https://github.com/jetsonhacks/rootOnNVMe cd rootOnNVMe ./copy-rootfs-ssd.sh ./setup-service.sh sudo reboot now 5. Installing JetPack SDK Components Finally, it is possible to install several JetPack SDK Compnents. The are useful for instance for running conatiners using Docker. To do this, this guide from the carrier board manufactor was followed. Additionally, after the installation of all the selected componets, docker was configured to run wihtout root previleges using the command sudo usermod -aG docker $USER , after which it is required to log out and log back in. 6. Installing ROS The version of the installed OS is based on Ubuntu 20.04 for which the latest version of ROS1 is ROS Noetic . To install it, the official guide in the ROS wiki was followed. Setup sources.list sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Setup keys sudo apt install curl curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - sudo apt update Installation (the desktop-full variant was selected for this specific installation) sudo apt install ros-noetic-desktop-full Environment setup echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc source ~/.bashrc Dependencies for building packages sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential sudo rosdep init rosdep update","title":"OS and ROS installation"},{"location":"Software%20Setup/os_installation/#os-and-ros-installation","text":"At the date of writing the most recent version of the JetPack software suppoted by the NVIDIA Jetson Xavier NX module and the Connect Tech Photon carrier board is version 5.1.1 . The following steps describe how to install this JetPack version on the onboard computer.","title":"OS and ROS Installation"},{"location":"Software%20Setup/os_installation/#1-sdk-manager","text":"The installation of the operating system must be made using the NVIDIA SDK Manager running on a computer with Ubuntu 18.04 or Ubuntu 20.04 . For reference, the installation was made using a machine with Ubuntu 18.04 and the SDK Manager version 1.9.1.10899 .","title":"1. SDK Manager"},{"location":"Software%20Setup/os_installation/#2-board-support-package-installation","text":"The carrier board manufactor provides a Board Support Package (BSP) that ensures the correct functioning of the OS with the carrier board. To do this, clear instructions are provided here . During this process, the Jetson Xavier NX modules was selected as the target hardware and the JetPack 5.1.1 (rev. 1) was selected as the target OS. Additionally, the BSP version NX L4T r35.3.1 BSP was downloaded from the manufactor resource center . Given that the SDK Manager version used in the guide is outdated, the images below show the board, OS and target components selection. In step 11 of the guide, the following steps were taken to connect the onboard computer to the machine running the SDK Manager: Connect the Power Cable of the +12V Power Supply into the Barrel Jack; Plug the AC cable on the +12V Power Supply into the wall socket; Press the switch SW2 during 10 seconds to enter forced recovery mode; Press the switch SW2 once to reset the board; Plug in a USB-A to micro USB-B cable from the host machine to the OTG USB port located below the ethernet port on the carrier board; Verify the board is connected by running the lsusb on the host machine.","title":"2. Board Support Package Installation"},{"location":"Software%20Setup/os_installation/#3-first-boot","text":"After the OS installation, the first boot must be made by connecting a monitor and peripherals to the board so as to complete the initial setup and create a user. SSH is not available before creating a user and accepting the license terms. For reference, the username \"jetson\" was created.","title":"3. First Boot"},{"location":"Software%20Setup/os_installation/#4-booting-from-the-nvme-ssd","text":"Now that the OS is installed and working the, the NVMe SSD can be configured as the boot device. To do this it is first necessary to move the root filesystem to the drive. The following steps are according to the rootOnNVMe repository. git clone https://github.com/jetsonhacks/rootOnNVMe cd rootOnNVMe ./copy-rootfs-ssd.sh ./setup-service.sh sudo reboot now","title":"4. Booting from the NVMe SSD"},{"location":"Software%20Setup/os_installation/#5-installing-jetpack-sdk-components","text":"Finally, it is possible to install several JetPack SDK Compnents. The are useful for instance for running conatiners using Docker. To do this, this guide from the carrier board manufactor was followed. Additionally, after the installation of all the selected componets, docker was configured to run wihtout root previleges using the command sudo usermod -aG docker $USER , after which it is required to log out and log back in.","title":"5. Installing JetPack SDK Components"},{"location":"Software%20Setup/os_installation/#6-installing-ros","text":"The version of the installed OS is based on Ubuntu 20.04 for which the latest version of ROS1 is ROS Noetic . To install it, the official guide in the ROS wiki was followed. Setup sources.list sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' Setup keys sudo apt install curl curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - sudo apt update Installation (the desktop-full variant was selected for this specific installation) sudo apt install ros-noetic-desktop-full Environment setup echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrc source ~/.bashrc Dependencies for building packages sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential sudo rosdep init rosdep update","title":"6. Installing ROS"},{"location":"Software%20Setup/px4_configuration_checklist/","text":"PX4 Configuration Checklist After assembling the vehicle, the PX4 autopilot running on the flight computer must be configured. Here is a general checklist of what needs to be done before the first flight. All of these configurations can be done using the QGroundControl application. It should be noted that this checklist is based on the PX4 documentation and more detailed instructions are available there . Sensor orientation on vehicle; Compass calibration; Gyroscope calibration; Accelerometer calibration; Radio setup (button mapping and calibration); Flight mode configuration (map radio button for manual/offboard mode change and safety hold/kill switch button); Battery (configure battery parameters for charge estimation); Configure failsafes; Actuators (configure geometry of motors and verify correct direction of spinning); After this process the vehicle should be ready for manual flight and it is now a good idea to check if the PID controllers' gains need to be adjusted.","title":"PX4 Configuration Checklist"},{"location":"Software%20Setup/px4_configuration_checklist/#px4-configuration-checklist","text":"After assembling the vehicle, the PX4 autopilot running on the flight computer must be configured. Here is a general checklist of what needs to be done before the first flight. All of these configurations can be done using the QGroundControl application. It should be noted that this checklist is based on the PX4 documentation and more detailed instructions are available there . Sensor orientation on vehicle; Compass calibration; Gyroscope calibration; Accelerometer calibration; Radio setup (button mapping and calibration); Flight mode configuration (map radio button for manual/offboard mode change and safety hold/kill switch button); Battery (configure battery parameters for charge estimation); Configure failsafes; Actuators (configure geometry of motors and verify correct direction of spinning); After this process the vehicle should be ready for manual flight and it is now a good idea to check if the PID controllers' gains need to be adjusted.","title":"PX4 Configuration Checklist"},{"location":"Software%20Setup/usefull_packages/","text":"Usefull Packages In order to facilitate testing and operation of the drone, two ROS packages are provided. mav_tools The mav_tools ROS package runs on top of MAVROS to provide a GUI interface that can run on the terminal and is able to display information like the battery state and basic control of the drone, like changing flight mode and arming/disarming the vehicle. test_comms_pixhawk The test_comms_pixhawk package provides an easy way to test the communication from the ROS control stack to the pixhawk flight computer by logging telemetry data and arming and disarming the drone.","title":"Usefull Packages"},{"location":"Software%20Setup/usefull_packages/#usefull-packages","text":"In order to facilitate testing and operation of the drone, two ROS packages are provided.","title":"Usefull Packages"},{"location":"Software%20Setup/usefull_packages/#mav_tools","text":"The mav_tools ROS package runs on top of MAVROS to provide a GUI interface that can run on the terminal and is able to display information like the battery state and basic control of the drone, like changing flight mode and arming/disarming the vehicle.","title":"mav_tools"},{"location":"Software%20Setup/usefull_packages/#test_comms_pixhawk","text":"The test_comms_pixhawk package provides an easy way to test the communication from the ROS control stack to the pixhawk flight computer by logging telemetry data and arming and disarming the drone.","title":"test_comms_pixhawk"},{"location":"Software%20Setup/vrpn_and_mavros/","text":"VRPN and MAVROS Setup VRPN In order to access data from the Optitrack MOCAP system the vrpn_client_ros package was used. sudo apt install ros-noetic-vrpn-client-ros This package listens on the IP of the computer running the MOCAP sosftware and introduces pose information of the captured rigid bodies into ros topics. To do this a launch file is provided: roslaunch vrpn_client_ros sample.launch In this launch file, the available parameters were configured as such (The IP used corresponds to the MOCAP system of the 8th floor at ISR-Alameda): server : 192.168.0.2 port : 3883 update_frequency : 30.0 frame_id : world use_server_time : false broadcast_tf : true refresh_tracker_frequency : 0.2 MAVROS To communicate with the flight computer (running the PX4 autopilot) using the MAVLink protocol through ROS, the MAVROS package was used. It is assumed that the flight computer is connected to the onboard computer through USB. sudo apt install ros-noetic-mavros sudo apt install ros-noetic-mavros-extras cd /opt/ros/noetic/lib/mavros sudo ./install_geographiclib_datasets.sh Additionally, to allow access to the USB ports for serial communication with the flight computer, these commands are needed: sudo gpasswd -a $USER dialout sudo reboot now The package can now be tested by running roslaunch mavros px4.launch and verifying that data is being published in the available ROS topics ( rostopic list and rostopic echo ... ). The MAVROS package also allows to redirect the MAVLink communications to another computer, where QGroundControl can be used for example. To do this, an option can be included when calling the launch file - roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@${GCS_IP}:${GCS_PORT} , where fcu_url is where the flight computer is connected, GCS_IP is the IP of the computer that wants to access the MAVLink communications and GCS_Port is an arbitrary port. MAVROS Example Onboard computer IP: 192.168.1.126; Flight computer connected to onboard computer through USB (/dev/ttyACM0); Other computer IP: 192.168.1.118; Run roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@192.168.1.118:15001 on the onboard computer; Run roslaunch mavros px4.launch fcu_url:=udp://:15001@ gcs_url:=udp://@localhost:15002 on the other computer; rostopic list and rostopic echo ... on the other computer will show the data from the flight computer; QGroundControl can be used on the other computer on port 15002.","title":"VRPN and MAVROS setup"},{"location":"Software%20Setup/vrpn_and_mavros/#vrpn-and-mavros-setup","text":"","title":"VRPN and MAVROS Setup"},{"location":"Software%20Setup/vrpn_and_mavros/#vrpn","text":"In order to access data from the Optitrack MOCAP system the vrpn_client_ros package was used. sudo apt install ros-noetic-vrpn-client-ros This package listens on the IP of the computer running the MOCAP sosftware and introduces pose information of the captured rigid bodies into ros topics. To do this a launch file is provided: roslaunch vrpn_client_ros sample.launch In this launch file, the available parameters were configured as such (The IP used corresponds to the MOCAP system of the 8th floor at ISR-Alameda): server : 192.168.0.2 port : 3883 update_frequency : 30.0 frame_id : world use_server_time : false broadcast_tf : true refresh_tracker_frequency : 0.2","title":"VRPN"},{"location":"Software%20Setup/vrpn_and_mavros/#mavros","text":"To communicate with the flight computer (running the PX4 autopilot) using the MAVLink protocol through ROS, the MAVROS package was used. It is assumed that the flight computer is connected to the onboard computer through USB. sudo apt install ros-noetic-mavros sudo apt install ros-noetic-mavros-extras cd /opt/ros/noetic/lib/mavros sudo ./install_geographiclib_datasets.sh Additionally, to allow access to the USB ports for serial communication with the flight computer, these commands are needed: sudo gpasswd -a $USER dialout sudo reboot now The package can now be tested by running roslaunch mavros px4.launch and verifying that data is being published in the available ROS topics ( rostopic list and rostopic echo ... ). The MAVROS package also allows to redirect the MAVLink communications to another computer, where QGroundControl can be used for example. To do this, an option can be included when calling the launch file - roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@${GCS_IP}:${GCS_PORT} , where fcu_url is where the flight computer is connected, GCS_IP is the IP of the computer that wants to access the MAVLink communications and GCS_Port is an arbitrary port.","title":"MAVROS"},{"location":"Software%20Setup/vrpn_and_mavros/#mavros-example","text":"Onboard computer IP: 192.168.1.126; Flight computer connected to onboard computer through USB (/dev/ttyACM0); Other computer IP: 192.168.1.118; Run roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@192.168.1.118:15001 on the onboard computer; Run roslaunch mavros px4.launch fcu_url:=udp://:15001@ gcs_url:=udp://@localhost:15002 on the other computer; rostopic list and rostopic echo ... on the other computer will show the data from the flight computer; QGroundControl can be used on the other computer on port 15002.","title":"MAVROS Example"},{"location":"Vehicle%20Setup/","text":"Vehicle Setup This section documents in detail the entire vehicle setup, including all the hardware components that make up the vehicle as well as the entire software package that allows it to function. In this way, the section is divided into two main subsections: Hardware Setup - describes the main hardware components of the vehicle; Software Setup - describes the software used, including the installation processes.","title":"Vehicle Setup"},{"location":"Vehicle%20Setup/#vehicle-setup","text":"This section documents in detail the entire vehicle setup, including all the hardware components that make up the vehicle as well as the entire software package that allows it to function. In this way, the section is divided into two main subsections: Hardware Setup - describes the main hardware components of the vehicle; Software Setup - describes the software used, including the installation processes.","title":"Vehicle Setup"}]}
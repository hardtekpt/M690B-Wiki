{"config":{"lang":["en","pt"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"M690B Wiki","text":"<p>This Wiki contains the documentation for preparing, testing and conducting indoor/outdoor missions using the M690B drone. Additionally, the procedures used and the results obtained in the FIREPUMA and CAPTURE missions will also be documented.</p> 1 / 5 2 / 5 3 / 5 4 / 5 5 / 5 \u276e \u276f"},{"location":"known_issues/","title":"Known issues","text":""},{"location":"known_issues/#os-not-booting-into-gui","title":"OS not booting into GUI","text":"<p>Sometimes when booting the onboard computer with a monitor and peripherals attached, the OS does not boot into the GUI but is still accessible through SSH. It was found that running the command <code>sudo systemctl set-default graphical.target</code> and rebooting seems to resolve this issue.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<ul> <li> Verify drone instrumentation: <ul> <li> Install OS - Jetpack 5</li> <li> Install ROS and setup workspace</li> <li> Setup the VRPN ROS package</li> <li> Setup the MAVROS package</li> <li> Verify communication between MAVROS and the Pixhawk</li> <li> Install the ROS control stack</li> <li> Verify communication between the ROS nodes and the Pixhawk</li> <li> Setup and test QGroundControl</li> <li> Test QGC with the telemetry radio</li> <li> Calibrate the flight controller</li> </ul> </li> <li> Verify drone sanity flight (manual mode, at ISR-Tagus and/or Cybaer-lab): <ul> <li> Gazebo simulation with the mission algorithm running on the onboard computer</li> <li> Indoor power on (no blades)</li> <li> Outdoor power on with blades (see if Pixhawk controller gains need to be changed)</li> </ul> </li> <li> Range test</li> <li> Manual flight with data acquisition and ground monitoring</li> <li> Dummy weight lifting tests (see if Pixhawk controller gains need to be changed) (no onboard computer installed) - create thrust curve.</li> <li> PixHawk autonomous mission mode trials:<ul> <li> Takeoff, hover, land (see if controller gains need to be changed)</li> <li> Typical mission for the controllers to be tested</li> <li> Off-board controller(s) running but not controlling vehicle (collected data used afterwards to see response of off-board controllers)</li> </ul> </li> <li> First off-board waypoint simple controller, no MPC, Guassian and/or GM;</li> <li> Online off-board MPC mission for PirePuma algorithms;</li> <li> Repeat previous trials with improved missions or algorithms.</li> </ul>"},{"location":"Hardware%20Setup/","title":"Hardware Setup","text":"<p>This section describes the various hardware components of vehicle. Namely, the Onboard Computer, the Flight Computer and the Radio and Receiver.</p>"},{"location":"Hardware%20Setup/flight_computer/","title":"Flight Computer","text":"<p>The flight computer for this vehicle consists of a Holybro Pixhawk 6C board. To communicate with the board, the USB-C port can be used. Alternatively, the TELEM (1,2,3) ports can be used together with an FTDI adapter. In the latter, the documentation shows how to wire the cable between the TELEM port and the FTDI adaptor.</p> <p></p>"},{"location":"Hardware%20Setup/onboard_computer/","title":"Onboard Computer","text":"<p>The onboard computer for this vehicle consists of an NVIDIA Jetson Xavier NX board which is installed in the Connect Tech Photon carrier board. The specific version of board is the REV G, SN5320, NGX002. Additionally, a 1 TB NVMe SSD was installed in the M.2 2280 M-KEY slot in the carrier board. To ensure the use of the SSD is enabled, the onboard DIP switch SW1-2 should be on the ON position. More information regarding the operation of the carrier board and connector location can be found in the carrier board manual.</p> <p></p>"},{"location":"Hardware%20Setup/onboard_computer_v2/","title":"Onboard Computer","text":"<p>In a second iteration of the vehicle, the onboard computer was switched to an NVIDIA Jetson Orin Nano which already comes with its own carrier board (developed by NVIDIA). The specific model used is the 8GB Developer Kit version. Besides switching to a newer version of the board (Orin vs Xavier), the Orin Nano also includes some GPIO pins which can be used to directly connect to the flight computer without the need for an FTDI adaptor.</p> <p></p>"},{"location":"Hardware%20Setup/radio_and_receiver/","title":"Radio and Receiver","text":""},{"location":"Hardware%20Setup/radio_and_receiver/#radio","title":"Radio","text":"<p>The radio used is the Taranis X9D Plus. The transmitter was binded to the receiver according to the instructions provided by the receiver manufactor and a new model for the M690B was created on the transmitter. The inputs and channel mixer were mapped as following.</p> INPUTS Mapping MIXER Description Thr Thr CH1 Engine Ail Ail CH2 Roll Ele Ele CH3 Pitch Rud Rud CH4 Yaw FMod SE CH5 Flight Mode Offb SB CH6 Offboard Kill SC CH7 Kill SW ARM SD CH8 ARM SW <p></p>"},{"location":"Hardware%20Setup/radio_and_receiver/#receiver","title":"Receiver","text":"<p>The receiver used is the FrSky X8R which is connected to the flight computer using the SBUS connection. Instructions to bind the receiver with the transmitter can be found here.</p>"},{"location":"Mission%20Logs/","title":"Mission Logs","text":"<p>This section contains reports and logs from the missions executed with the M690B drone. These include ulog files from the flight computer, rosbag files from the onboard computer and video footage from the missions. Some useful tools for analysing the logs are: PX4 Flight Review and Plotjuggler.</p>"},{"location":"Mission%20Logs/05-07-2023/","title":"05-07-2023","text":"<p>In this trial, both drones from IST and NOVA flew for the first time. Only manual flight was tested and the controller gains were tuned.</p>"},{"location":"Mission%20Logs/05-07-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/05-07-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/05-07-2023/#m690b-ist","title":"M690B IST","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/05-07-2023/#m690b-nova","title":"M690B NOVA","text":"<ul> <li>Logs from the flight computer</li> </ul>"},{"location":"Mission%20Logs/05-07-2023/#flight-plan","title":"Flight Plan","text":""},{"location":"Mission%20Logs/13-07-2023/","title":"13-07-2023","text":"<p>In this trial, the drone from IST was used in several manual flights in order to adjust the gains of the PID controllers. The test was successful resulting in the drone having a decent reaction to the control inputs.</p>"},{"location":"Mission%20Logs/13-07-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/13-07-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/13-07-2023/#m690b-ist","title":"M690B IST","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/13-07-2023/#m690b-nova","title":"M690B NOVA","text":"<ul> <li>Logs from the flight computer</li> </ul>"},{"location":"Mission%20Logs/13-07-2023/#flight-plan","title":"Flight Plan","text":""},{"location":"Mission%20Logs/13-10-2023/","title":"13-10-2023","text":"<p>In this trial, the drone from IST was used in autonomous flights in order to find its maximum velocity. The test was considered a success with a maximum velocity obatined of 68km/h.</p>"},{"location":"Mission%20Logs/13-10-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/13-10-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/13-10-2023/#m690b-ist","title":"M690B IST","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/13-10-2023/#flight-plan","title":"Flight Plan","text":""},{"location":"Mission%20Logs/20-07-2023/","title":"20-07-2023","text":"<p>In this trial, the drone from IST was used in several manual and GPS flights in order to test safety modes based on GPS navigation such as the return-to-launch mode. Tests using different payloads were also conducted, adding 1kg, and 2kg payloads and hovering in Position mode, yet the drone revealed to be near instability when carrying 2kg, for which further PID adjustment is needed, and when landing, it tilted forward and two propellers were damaged. After replacing the propellers, removing the weights, and checking for airworthiness, a basic offboard mode test was conducted, using waypoints describing a square.</p>"},{"location":"Mission%20Logs/20-07-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/20-07-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/20-07-2023/#m690b-ist","title":"M690B IST","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/20-07-2023/#flight-plan","title":"Flight Plan","text":""},{"location":"Mission%20Logs/22-09-2023/","title":"22-09-2023","text":"<p>In this trial, the drone from IST was used in autonomous waypoint flights. The drone behaved as expected apart from the yaw angle which did not correspond to the desired values.</p>"},{"location":"Mission%20Logs/22-09-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/22-09-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/22-09-2023/#m690b-ist","title":"M690B IST","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/22-09-2023/#flight-plan","title":"Flight Plan","text":""},{"location":"Mission%20Logs/27-07-2023/","title":"27-07-2023","text":"<p>In this trial, the drones from IST and NOVA were used in several Manual and GPS flights in order to test basic functionality of the new NVidia Orin Nano Board on the NOVA drone, and also acquire data using the Intel RealSense D455 onboard the IST drone. As it was too windy, further offboard mode trials were postponed.</p>"},{"location":"Mission%20Logs/27-07-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/27-07-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/27-07-2023/#m690b-ist","title":"M690B IST","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/27-07-2023/#m690b-nova","title":"M690B NOVA","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/27-07-2023/#flight-plan","title":"Flight Plan","text":""},{"location":"Mission%20Logs/28-07-2023/","title":"28-07-2023","text":"<p>In this trial, the drone from NOVA was used in several GPS flights in order to acquire data using the Intel RealSense D455 onboard the NOVA drone as well as test basic and regular waypoint-based offboard missions. It was still too windy, yet the trials were considered to be a success.</p>"},{"location":"Mission%20Logs/28-07-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/28-07-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/28-07-2023/#m690b-nova","title":"M690B NOVA","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/28-07-2023/#flight-plan","title":"Flight Plan","text":""},{"location":"Mission%20Logs/29-09-2023/","title":"22-09-2023","text":"<p>In this trial, the drone from IST was used in more autonomous waypoint flights. The drone behaved as expected apart from the yaw angle which did not correspond to the desired values. Also, the drone from NOVA was used for manual payload tests, managing to fly without issues with 2Kg and with some stability issues with 3Kg which was considered a success.</p>"},{"location":"Mission%20Logs/29-09-2023/#footage","title":"Footage","text":"<ul> <li>Videos and photos</li> </ul>"},{"location":"Mission%20Logs/29-09-2023/#logs","title":"Logs","text":""},{"location":"Mission%20Logs/29-09-2023/#m690b-ist","title":"M690B IST","text":"<ul> <li>Logs from the flight computer</li> <li>Rosbags from the onboard computer</li> </ul>"},{"location":"Mission%20Logs/29-09-2023/#m690b-nova","title":"M690B NOVA","text":"<ul> <li>Logs from the flight computer</li> </ul>"},{"location":"Software%20Setup/","title":"Software Setup","text":"<p>This section describes in detail all the procedures used to install and configure the software that runs on the vehicle's hardware components. Namely, the OS and ROS installation on the onboard computer, the VRPN and MAVROS Setup, the PX4 Configuration Checklist, the Drone Control Stack Setup and some Usefull Packages.</p> <pre><code>graph LR\n  A(MOCAP) -- UDP --&gt; B(ROUTER)\n  B -- UDP --&gt; C(vrpn_client_ros)\n  subgraph Onboard Computer\n    C -- ROSTOPIC --- D(MAVROS)\n    G(\"Main Algorithm (Mission)\") -- ROSTOPIC --- D\n  end\n  subgraph Flight Computer\n    D -- MAVLINK --- E(PX4-Autopilot)\n  end\n  B -- \"UDP (gcs_url)\" --- D\n  subgraph Companion Computer\n    F(QGroundControl)\n  end\n  F -- \"UDP (fcu_url)\" --- B\n  F-. \"TELEM RADIO\" .- E</code></pre>"},{"location":"Software%20Setup/drone_console/","title":"Drone Console","text":"<p>This section describes the console created to facilitate the process of monitoring the vehicle and running offboard algorithms during real trials. It contains several features like battery monitoring and access to the PX4 via mavros.</p>"},{"location":"Software%20Setup/drone_console/#installation","title":"Installation","text":"<p>The files required for the drone console include the mav_tools ROS package as well as a couple of scripts which can be found here. The scripts folder should be placed in the home folder and the mav_tools package should be placed in the catkin workspace.</p> <p>Note</p> <p>To run the <code>drone_console.bash</code> when the drone boots, add this to your crontab (<code>crontab -e</code>): <code>@reboot /home/jetson/scripts/drone_console.bash</code></p>"},{"location":"Software%20Setup/drone_console/#usage","title":"Usage","text":"<p>To open the drone console start by login in into the drone. To make it easier, add this to your <code>bashrc</code>:</p> <p>'''bash alias drone_console='tmux a -t drone_console' '''</p> <p>In this way, the console can be accessed using the <code>drone_console</code> command.</p>"},{"location":"Software%20Setup/drone_console/#demo","title":"Demo","text":"<p>In the main window, there are four panels. In the top left is the mav_tools ros package, which allows easy monitoring and basic control of the vehicle. In the bottom left, mavros is running, so that a connection to the PX4 is always available via ROS. In the top right, a terminal is available for running the offboard algorithms. Finally, in the bottom right a terminal has the <code>drone_bringup.launch</code> file open so that the mission to be ran can be configured.</p> <p></p> <p>In the second window a panel shows the recorded rosbag files and a second panel provides an auxiliary terminal.</p> <p></p>"},{"location":"Software%20Setup/drone_control_stack/","title":"Drone Control Stack Setup","text":"<p>This section describes the steps followed to install the drone control stack on the onboard computer. This stack is composed of ROS packages which allow the vehicle to be controlled from ROS nodes using the available cpp UAV class. It should be noted that the steps described include everything that is needed to run simulations in adition to controlling the real drone.</p>"},{"location":"Software%20Setup/drone_control_stack/#environment-setup","title":"Environment Setup","text":"<p>Before installing the ROS packages, it is necessary to create a workspace and install the PX4 firmware (only used for simulations).</p> <ul> <li> <p>Creating a catkin workspace     <pre><code>mkdir ~/uav/uav_ws/src\ncd ~/uav/uav_ws\ncatkin_make\n</code></pre></p> </li> <li> <p>Installing the PX4 firmware     <pre><code>cd ~/uav\ngit clone --recursive https://github.com/PX4/PX4-Autopilot.git\ncd PX4-Autopilot\ngit fetch --all --tags\ngit checkout v1.12.3 -b latest\ngit submodule update --init --recursive\nmake px4_sitl gazebo\n</code></pre></p> </li> </ul> <p>Note</p> <p>While installing the PX4 firmware, some missing packages might need to be installed with pip. If pip is not available it can be installed with <code>sudo apt install python3-pip</code>.</p> <ul> <li> <p>In order not to pollute the <code>bashrc</code> profile, a script was created to load the needed environment variables     <pre><code>cd ~/uav\ntouch setup.bash\n</code></pre></p> </li> <li> <p>Contents of the <code>setup.bash</code> file     <pre><code>source ~/uav/uav_ws/devel/setup.bash\n\nexport CATKIN_WORKSPACE=~/uav/uav_ws\n\nexport GAZEBO_PLUGIN_PATH=$GAZEBO_PLUGIN_PATH:/home/jetson/uav/PX4-Autopilot/build_gazebo\nexport GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo/models\n\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jetson/uav/PX4-Autopilot/build_gazebo\nexport ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:/home/jetson/uav/PX4-Autopilot:/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo\n\nsource /home/jetson/uav/PX4-Autopilot/Tools/setup_gazebo.bash /home/jetson/uav/PX4-Autopilot /home/jetson/uav/PX4-Autopilot/build/px4_sitl_default\n</code></pre></p> </li> </ul>"},{"location":"Software%20Setup/drone_control_stack/#control-stack-overview","title":"Control Stack Overview","text":"<p>Now that the environment is prepared, the code stack can be installed inside the created workspace. Below is a tree view of all the packages included in the stack. The packages listed here are available in this repository.</p> <pre><code>src/\n\u251c\u2500\u2500 drone_bringup\n\u251c\u2500\u2500 drone_gazebo\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 drone_description\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_worlds\n\u251c\u2500\u2500 drone_launch\n\u2514\u2500\u2500 drone_library\n \u00a0\u00a0 \u251c\u2500\u2500 drone_gimmicks_library\n \u00a0\u00a0 \u251c\u2500\u2500 drone_utils_cpp\n \u00a0\u00a0 \u2514\u2500\u2500 mavros_cpp\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#simulation-flow","title":"Simulation flow","text":"<pre><code>graph TD\n  A(&lt;b&gt;simulator_bringup.launch&lt;/b&gt; &lt;br&gt; drone_launch) --&gt; B(&lt;b&gt;vehicle_bringup.launch&lt;/b&gt; &lt;br&gt; drone_launch);\n  A --&gt; C(&lt;b&gt;empty_world.launch&lt;/b&gt; &lt;br&gt; gazebo_ros);\n  A -. simulator_bringup_rviz.launch .-&gt; G(&lt;b&gt;rviz&lt;/b&gt; &lt;br&gt; rviz);\n  B --&gt; D(&lt;b&gt;single_vehicle_spawn.launch&lt;/b&gt; &lt;br&gt; drone_launch);\n  B --&gt; E(&lt;b&gt;px4.launch&lt;/b&gt; &lt;br&gt; mavros);\n  B --&gt; F(&lt;b&gt;drone_sim.launch&lt;/b&gt; &lt;br&gt; drone_bringup);</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#real-mission-flow","title":"Real mission flow","text":"<pre><code>graph TD\n  A(&lt;b&gt;real_bringup_rviz.launch&lt;/b&gt; &lt;br&gt; drone_launch) --&gt; B(&lt;b&gt;px4.launch&lt;/b&gt; &lt;br&gt; mavros);\n  A --&gt; C(&lt;b&gt;drone_sim.launch&lt;/b&gt; &lt;br&gt; drone_bringup);\n  A --&gt; G(&lt;b&gt;rviz&lt;/b&gt; &lt;br&gt; rviz);</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#ros-packages-overview","title":"ROS Packages Overview","text":""},{"location":"Software%20Setup/drone_control_stack/#drone_bringup","title":"drone_bringup","text":"<p>The <code>drone_sim.launch</code> file loads the vehicle and main algorithm parameters and calls the ROS node that has the mission to be carried out.</p> <pre><code>src/drone_bringup/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 simulation\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 iris\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 config.yaml\n\u251c\u2500\u2500 launch\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_sim.launch\n\u2514\u2500\u2500 package.xml\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#drone_description","title":"drone_description","text":"<p>The <code>drone_description</code> package contains the Gazebo models for the vehicles used.</p> <pre><code>src/drone_gazebo/drone_description/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 models\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 iris\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 iris.sdf.jinja\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 iris.urdf\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 meshes\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 iris_prop_ccw.dae\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 iris_prop_cw.dae\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 iris.stl\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 model.config\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 scripts\n    \u251c\u2500\u2500 jinja_gen.py\n    \u251c\u2500\u2500 names.py\n    \u251c\u2500\u2500 schema_download.bash\n    \u251c\u2500\u2500 substitution_args.py\n    \u2514\u2500\u2500 validate_sdf.bash\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#drone_worlds","title":"drone_worlds","text":"<p>The <code>drone_worlds</code> package contains the world files that can be used during simulations in Gzaebo.</p> <pre><code>src/drone_gazebo/drone_worlds/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 worlds\n    \u251c\u2500\u2500 baylands.world\n    \u251c\u2500\u2500 boat.world\n    \u251c\u2500\u2500 empty.world\n    \u251c\u2500\u2500 hippocampus.world\n    \u251c\u2500\u2500 hitl_iris.world\n    \u251c\u2500\u2500 hitl_standard_vtol.world\n    \u251c\u2500\u2500 iris_irlock.world\n    \u251c\u2500\u2500 ksql_airport.world\n    \u251c\u2500\u2500 mcmillan_airfield.world\n    \u251c\u2500\u2500 ocean.world\n    \u251c\u2500\u2500 sonoma_raceway.world\n    \u251c\u2500\u2500 typhoon_h480.world\n    \u251c\u2500\u2500 uuv_bluerov2_heavy.world\n    \u251c\u2500\u2500 uuv_hippocampus.world\n    \u251c\u2500\u2500 warehouse.world\n    \u251c\u2500\u2500 windy.world\n    \u2514\u2500\u2500 yosemite.world\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#drone_launch","title":"drone_launch","text":"<p>The <code>drone_launch</code> package contains several launch files that are used to run simulations and to run missions with the real drone.</p> <pre><code>src/drone_launch/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 real_bringup_rviz.launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 rvizcfg.rviz\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 simulator_bringup.launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 simulator_bringup_rviz.launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 single_vehicle_spawn.launch\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 vehicle_bringup.launch\n\u2514\u2500\u2500 package.xml\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#drone_gimmicks_library","title":"drone_gimmicks_library","text":"<p>The <code>drone_gimmicks_library</code> package contains some useful macros to reduce the complexity of some common ROS operations like getting parameters.</p> <pre><code>src/drone_library/drone_gimmicks_library/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_gimmicks_library\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 DroneGimmicks.h\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 DroneGimmicks.cpp\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#drone_utils_cpp","title":"drone_utils_cpp","text":"<p>The <code>drone_utils_cpp</code> package contains some useful functions while working with drones, like converting between different coordinate frames and normalizing thrust values.</p> <pre><code>src/drone_library/drone_utils_cpp/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 doc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_utils_cpp\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 DroneInfo.h\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 DroneStatus.h\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 Utils.h\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 Utils.cpp\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#mavros_cpp","title":"mavros_cpp","text":"<p>The <code>mavros_cpp</code> package contains the main class (UAV) which is used to control the drone as well as to get telemetry data.</p> <pre><code>src/drone_library/mavros_cpp/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 doc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 mavros_cpp\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 Actuators.h\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 EKF.h\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 Sensors.h\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 UAV.h\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 offboard.cpp\n    \u251c\u2500\u2500 telemetry.cpp\n    \u2514\u2500\u2500 UAV.cpp\n</code></pre>"},{"location":"Software%20Setup/drone_control_stack/#simulation-example","title":"Simulation example","text":"<p>After installing the code stack the provided lissajous example package can be executed in simulation. The <code>drone_sim.launch</code> file in the <code>drone_bringup</code> package should contain a call to the <code>lissajous</code> ROS node like so - <code>&lt;node pkg=\"lissajous\" type=\"lissajous_node\" name=\"lissajous\" respawn=\"false\" output=\"screen\"/&gt;</code>.</p> <ol> <li> <p>Build the workspace     <pre><code>cd ~/uav/uav_ws\ncatkin_make\n</code></pre></p> </li> <li> <p>Source the provided bash script     <pre><code>cd ~/uav\nsource setup.bash\n</code></pre></p> </li> <li> <p>Run the simulation     <pre><code>roslaunch drone_launch simulator_bringup.launch\n</code></pre></p> <p></p> </li> </ol>"},{"location":"Software%20Setup/os_installation/","title":"OS and ROS Installation","text":"<p>At the date of writing the most recent version of the JetPack software suppoted by the NVIDIA Jetson Xavier NX module and the Connect Tech Photon carrier board is version 5.1.1. The following steps describe how to install this JetPack version on the onboard computer.  </p>"},{"location":"Software%20Setup/os_installation/#1-sdk-manager","title":"1. SDK Manager","text":"<p>The installation of the operating system must be made using the NVIDIA SDK Manager running on a computer with Ubuntu 18.04 or Ubuntu 20.04. For reference, the installation was made using a machine with Ubuntu 18.04 and the SDK Manager version 1.9.1.10899.</p>"},{"location":"Software%20Setup/os_installation/#2-board-support-package-installation","title":"2. Board Support Package Installation","text":"<p>The carrier board manufactor provides a Board Support Package (BSP) that ensures the correct functioning of the OS with the carrier board. To do this, clear instructions are provided here. During this process, the Jetson Xavier NX modules was selected as the target hardware and the JetPack 5.1.1 (rev. 1) was selected as the target OS. Additionally, the BSP version NX L4T r35.3.1 BSP was downloaded from the manufactor resource center. Given that the SDK Manager version used in the guide is outdated, the images below show the board, OS and target components selection.</p> <p> </p> <p>In step 11 of the guide, the following steps were taken to connect the onboard computer to the machine running the SDK Manager:</p> <ol> <li>Connect the Power Cable of the +12V Power Supply into the Barrel Jack;</li> <li>Plug the AC cable on the +12V Power Supply into the wall socket;</li> <li>Press the switch SW2 during 10 seconds to enter forced recovery mode;</li> <li>Press the switch SW2 once to reset the board;</li> <li>Plug in a USB-A to micro USB-B cable from the host machine to the OTG USB port located below the ethernet port on the carrier board;</li> <li>Verify the board is connected by running the <code>lsusb</code> on the host machine.</li> </ol>"},{"location":"Software%20Setup/os_installation/#3-first-boot","title":"3. First Boot","text":"<p>After the OS installation, the first boot must be made by connecting a monitor and peripherals to the board so as to complete the initial setup and create a user. SSH is not available before creating a user and accepting the license terms. For reference, the username \"jetson\" was created.</p>"},{"location":"Software%20Setup/os_installation/#4-booting-from-the-nvme-ssd","title":"4. Booting from the NVMe SSD","text":"<p>Now that the OS is installed and working the, the NVMe SSD can be configured as the boot device. To do this it is first necessary to move the root filesystem to the drive. The following steps are according to the rootOnNVMe repository.</p> <pre><code>git clone https://github.com/jetsonhacks/rootOnNVMe\ncd rootOnNVMe\n./copy-rootfs-ssd.sh\n./setup-service.sh\nsudo reboot now\n</code></pre>"},{"location":"Software%20Setup/os_installation/#5-installing-jetpack-sdk-components","title":"5. Installing JetPack SDK Components","text":"<p>Finally, it is possible to install several JetPack SDK Compnents. The are useful for instance for running conatiners using Docker. To do this, this guide from the carrier board manufactor was followed.</p> <p>Additionally, after the installation of all the selected componets, docker was configured to run wihtout root previleges using the command <code>sudo usermod -aG docker $USER</code>, after which it is required to log out and log back in.</p>"},{"location":"Software%20Setup/os_installation/#6-installing-ros","title":"6. Installing ROS","text":"<p>The version of the installed OS is based on Ubuntu 20.04 for which the latest version of ROS1 is ROS Noetic. To install it, the official guide in the ROS wiki was followed.</p> <ol> <li> <p>Setup sources.list     <pre><code>sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list'\n</code></pre></p> </li> <li> <p>Setup keys     <pre><code>sudo apt install curl\ncurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -\nsudo apt update\n</code></pre></p> </li> <li> <p>Installation (the desktop-full variant was selected for this specific installation)     <pre><code>sudo apt install ros-noetic-desktop-full\n</code></pre></p> </li> <li> <p>Environment setup     <pre><code>echo \"source /opt/ros/noetic/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre></p> </li> <li> <p>Dependencies for building packages     <pre><code>sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential\n\nsudo rosdep init\nrosdep update\n</code></pre></p> </li> </ol>"},{"location":"Software%20Setup/px4_configuration_checklist/","title":"PX4 Configuration Checklist","text":"<p>After assembling the vehicle, the PX4  autopilot running on the flight computer must be configured. Here is a general checklist of what needs to be done before the first flight. All of these configurations can be done using the QGroundControl application. It should be noted that this checklist is based on the PX4 documentation and more detailed instructions are available there.</p> <ol> <li>Sensor orientation on vehicle;</li> <li>Compass calibration;</li> <li>Gyroscope calibration;</li> <li>Accelerometer calibration;</li> <li>Radio setup (button mapping and calibration);</li> <li>Flight mode configuration (map radio button for manual/offboard mode change and safety hold/kill switch button);</li> <li>Battery (configure battery parameters for charge estimation);</li> <li>Configure failsafes;</li> <li>Actuators (configure geometry of motors and verify correct direction of spinning);</li> </ol> <p>After this process the vehicle should be ready for manual flight and it is now a good idea to check if the PID controllers' gains need to be adjusted.</p>"},{"location":"Software%20Setup/usefull_packages/","title":"Usefull Packages","text":"<p>In order to facilitate testing and operation of the drone, two ROS packages are provided.</p>"},{"location":"Software%20Setup/usefull_packages/#mav_tools","title":"mav_tools","text":"<p>The mav_tools ROS package runs on top of MAVROS to provide a GUI interface that can run on the terminal and is able to display information like the battery state and basic control of the drone, like changing flight mode and arming/disarming the vehicle.</p> <p></p>"},{"location":"Software%20Setup/usefull_packages/#test_comms_pixhawk","title":"test_comms_pixhawk","text":"<p>The test_comms_pixhawk package provides an easy way to test the communication from the ROS control stack to the pixhawk flight computer by logging telemetry data and arming and disarming the drone.</p>"},{"location":"Software%20Setup/vrpn_and_mavros/","title":"VRPN and MAVROS Setup","text":""},{"location":"Software%20Setup/vrpn_and_mavros/#vrpn","title":"VRPN","text":"<p>In order to access data from the Optitrack MOCAP system the vrpn_client_ros package was used.</p> <pre><code>sudo apt install ros-noetic-vrpn-client-ros\n</code></pre> <p>This package listens on the IP of the computer running the MOCAP sosftware and introduces pose information of the captured rigid bodies into ros topics. To do this a launch file is provided:</p> <pre><code>roslaunch vrpn_client_ros sample.launch\n</code></pre> <p>In this launch file, the available parameters were configured as such (The IP used corresponds to the MOCAP system of the 8th floor at ISR-Alameda):</p> <pre><code>server: 192.168.0.2\nport: 3883\nupdate_frequency: 30.0\nframe_id: world\nuse_server_time: false\nbroadcast_tf: true\nrefresh_tracker_frequency: 0.2\n</code></pre>"},{"location":"Software%20Setup/vrpn_and_mavros/#mavros","title":"MAVROS","text":"<p>To communicate with the flight computer (running the PX4 autopilot) using the MAVLink protocol through ROS, the MAVROS package was used. It is assumed that the flight computer is connected to the onboard computer through USB.</p> <pre><code>sudo apt install ros-noetic-mavros\nsudo apt install ros-noetic-mavros-extras\ncd /opt/ros/noetic/lib/mavros\nsudo ./install_geographiclib_datasets.sh \n</code></pre> <p>Additionally, to allow access to the USB ports for serial communication with the flight computer, these commands are needed:</p> <pre><code>sudo gpasswd -a $USER dialout\nsudo reboot now\n</code></pre> <p>The package can now be tested by running <code>roslaunch mavros px4.launch</code> and verifying that data is being published in the available ROS topics (<code>rostopic list</code> and <code>rostopic echo ...</code>).</p> <p>The MAVROS package also allows to redirect the MAVLink communications to another computer, where QGroundControl can be used for example. To do this, an option can be included when calling the launch file - <code>roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@${GCS_IP}:${GCS_PORT}</code>, where fcu_url is where the flight computer is connected, GCS_IP is the IP of the computer that wants to access the MAVLink communications and GCS_Port is an arbitrary port.</p>"},{"location":"Software%20Setup/vrpn_and_mavros/#mavros-example","title":"MAVROS Example","text":"<ol> <li>Onboard computer IP: 192.168.1.126; </li> <li>Flight computer connected to onboard computer through USB (/dev/ttyACM0);</li> <li>Other computer IP: 192.168.1.118;</li> <li>Run <code>roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@192.168.1.118:15001</code> on the onboard computer;</li> <li>Run <code>roslaunch mavros px4.launch fcu_url:=udp://:15001@ gcs_url:=udp://@localhost:15002</code> on the other computer;</li> <li><code>rostopic list</code> and <code>rostopic echo ...</code> on the other computer will show the data from the flight computer;</li> <li>QGroundControl can be used on the other computer on port 15002.</li> </ol>"},{"location":"Software%20Setup%20V11/","title":"Software Setup V2","text":"<p>This section describes in detail all the procedures used to install and configure the software that runs on the vehicle's hardware components. </p> <pre><code>graph LR\n  A(MOCAP) -- UDP --&gt; B(ROUTER)\n  B -- UDP --&gt; C(vrpn_client_ros)\n  subgraph Onboard Computer\n    C -- ROSTOPIC --- D(MAVROS)\n    G(\"Main Algorithm (Mission)\") -- ROSTOPIC --- D\n  end\n  subgraph Flight Computer\n    D -- MAVLINK --- E(PX4-Autopilot)\n  end\n  B -- \"UDP (gcs_url)\" --- D\n  subgraph Companion Computer\n    F(QGroundControl)\n  end\n  F -- \"UDP (fcu_url)\" --- B\n  F-. \"TELEM RADIO\" .- E</code></pre>"},{"location":"Software%20Setup%20V11/drone_console/","title":"Drone Console","text":"<p>This section describes the console created to facilitate the process of monitoring the vehicle and running offboard algorithms during real trials. It contains several features like battery monitoring and access to the PX4 via mavros.</p>"},{"location":"Software%20Setup%20V11/drone_console/#installation","title":"Installation","text":"<p>The files required for the drone console include the mav_tools ROS package as well as a couple of scripts which can be found here. The scripts folder should be placed in the home folder and the mav_tools package should be placed in the catkin workspace.</p> <p>Note</p> <p>To run the <code>drone_console.bash</code> when the drone boots, add this to your crontab (<code>crontab -e</code>): <code>@reboot /home/jetson/scripts/drone_console.bash</code></p>"},{"location":"Software%20Setup%20V11/drone_console/#usage","title":"Usage","text":"<p>To open the drone console start by login in into the drone. To make it easier, add this to your <code>bashrc</code>:</p> <p>'''bash alias drone_console='tmux a -t drone_console' '''</p> <p>In this way, the console can be accessed using the <code>drone_console</code> command.</p>"},{"location":"Software%20Setup%20V11/drone_console/#demo","title":"Demo","text":"<p>In the main window, there are four panels. In the top left is the mav_tools ros package, which allows easy monitoring and basic control of the vehicle. In the bottom left, mavros is running, so that a connection to the PX4 is always available via ROS. In the top right, a terminal is available for running the offboard algorithms. Finally, in the bottom right a terminal has the <code>drone_bringup.launch</code> file open so that the mission to be ran can be configured.</p> <p></p> <p>In the second window a panel shows the recorded rosbag files and a second panel provides an auxiliary terminal.</p> <p></p>"},{"location":"Software%20Setup%20V11/drone_control_stack/","title":"Drone Control Stack Setup","text":"<p>This section describes the steps followed to install the drone control stack on the onboard computer. This stack is composed of ROS packages which allow the vehicle to be controlled from ROS nodes using the available cpp UAV class. It should be noted that the steps described include everything that is needed to run simulations in adition to controlling the real drone.</p>"},{"location":"Software%20Setup%20V11/drone_control_stack/#environment-setup","title":"Environment Setup","text":"<p>Before installing the ROS packages, it is necessary to create a workspace and install the PX4 firmware (only used for simulations).</p> <ul> <li> <p>Creating a catkin workspace     <pre><code>mkdir ~/uav/uav_ws/src\ncd ~/uav/uav_ws\ncatkin_make\n</code></pre></p> </li> <li> <p>Installing the PX4 firmware     <pre><code>cd ~/uav\ngit clone --recursive https://github.com/PX4/PX4-Autopilot.git\ncd PX4-Autopilot\ngit fetch --all --tags\ngit checkout v1.12.3 -b latest\ngit submodule update --init --recursive\nmake px4_sitl gazebo\n</code></pre></p> </li> </ul> <p>Note</p> <p>While installing the PX4 firmware, some missing packages might need to be installed with pip. If pip is not available it can be installed with <code>sudo apt install python3-pip</code>.</p> <ul> <li> <p>In order not to pollute the <code>bashrc</code> profile, a script was created to load the needed environment variables     <pre><code>cd ~/uav\ntouch setup.bash\n</code></pre></p> </li> <li> <p>Contents of the <code>setup.bash</code> file     <pre><code>source ~/uav/uav_ws/devel/setup.bash\n\nexport CATKIN_WORKSPACE=~/uav/uav_ws\n\nexport GAZEBO_PLUGIN_PATH=$GAZEBO_PLUGIN_PATH:/home/jetson/uav/PX4-Autopilot/build_gazebo\nexport GAZEBO_MODEL_PATH=$GAZEBO_MODEL_PATH:/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo/models\n\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/jetson/uav/PX4-Autopilot/build_gazebo\nexport ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:/home/jetson/uav/PX4-Autopilot:/home/jetson/uav/PX4-Autopilot/Tools/sitl_gazebo\n\nsource /home/jetson/uav/PX4-Autopilot/Tools/setup_gazebo.bash /home/jetson/uav/PX4-Autopilot /home/jetson/uav/PX4-Autopilot/build/px4_sitl_default\n</code></pre></p> </li> </ul>"},{"location":"Software%20Setup%20V11/drone_control_stack/#control-stack-overview","title":"Control Stack Overview","text":"<p>Now that the environment is prepared, the code stack can be installed inside the created workspace. Below is a tree view of all the packages included in the stack. The packages listed here are available in this repository.</p> <pre><code>src/\n\u251c\u2500\u2500 drone_bringup\n\u251c\u2500\u2500 drone_gazebo\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 drone_description\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_worlds\n\u251c\u2500\u2500 drone_launch\n\u2514\u2500\u2500 drone_library\n \u00a0\u00a0 \u251c\u2500\u2500 drone_gimmicks_library\n \u00a0\u00a0 \u251c\u2500\u2500 drone_utils_cpp\n \u00a0\u00a0 \u2514\u2500\u2500 mavros_cpp\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#simulation-flow","title":"Simulation flow","text":"<pre><code>graph TD\n  A(&lt;b&gt;simulator_bringup.launch&lt;/b&gt; &lt;br&gt; drone_launch) --&gt; B(&lt;b&gt;vehicle_bringup.launch&lt;/b&gt; &lt;br&gt; drone_launch);\n  A --&gt; C(&lt;b&gt;empty_world.launch&lt;/b&gt; &lt;br&gt; gazebo_ros);\n  A -. simulator_bringup_rviz.launch .-&gt; G(&lt;b&gt;rviz&lt;/b&gt; &lt;br&gt; rviz);\n  B --&gt; D(&lt;b&gt;single_vehicle_spawn.launch&lt;/b&gt; &lt;br&gt; drone_launch);\n  B --&gt; E(&lt;b&gt;px4.launch&lt;/b&gt; &lt;br&gt; mavros);\n  B --&gt; F(&lt;b&gt;drone_sim.launch&lt;/b&gt; &lt;br&gt; drone_bringup);</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#real-mission-flow","title":"Real mission flow","text":"<pre><code>graph TD\n  A(&lt;b&gt;real_bringup_rviz.launch&lt;/b&gt; &lt;br&gt; drone_launch) --&gt; B(&lt;b&gt;px4.launch&lt;/b&gt; &lt;br&gt; mavros);\n  A --&gt; C(&lt;b&gt;drone_sim.launch&lt;/b&gt; &lt;br&gt; drone_bringup);\n  A --&gt; G(&lt;b&gt;rviz&lt;/b&gt; &lt;br&gt; rviz);</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#ros-packages-overview","title":"ROS Packages Overview","text":""},{"location":"Software%20Setup%20V11/drone_control_stack/#drone_bringup","title":"drone_bringup","text":"<p>The <code>drone_sim.launch</code> file loads the vehicle and main algorithm parameters and calls the ROS node that has the mission to be carried out.</p> <pre><code>src/drone_bringup/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 simulation\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 iris\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 config.yaml\n\u251c\u2500\u2500 launch\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_sim.launch\n\u2514\u2500\u2500 package.xml\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#drone_description","title":"drone_description","text":"<p>The <code>drone_description</code> package contains the Gazebo models for the vehicles used.</p> <pre><code>src/drone_gazebo/drone_description/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 models\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 iris\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 iris.sdf.jinja\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 iris.urdf\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 meshes\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 iris_prop_ccw.dae\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 iris_prop_cw.dae\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 iris.stl\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 model.config\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 scripts\n    \u251c\u2500\u2500 jinja_gen.py\n    \u251c\u2500\u2500 names.py\n    \u251c\u2500\u2500 schema_download.bash\n    \u251c\u2500\u2500 substitution_args.py\n    \u2514\u2500\u2500 validate_sdf.bash\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#drone_worlds","title":"drone_worlds","text":"<p>The <code>drone_worlds</code> package contains the world files that can be used during simulations in Gzaebo.</p> <pre><code>src/drone_gazebo/drone_worlds/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 worlds\n    \u251c\u2500\u2500 baylands.world\n    \u251c\u2500\u2500 boat.world\n    \u251c\u2500\u2500 empty.world\n    \u251c\u2500\u2500 hippocampus.world\n    \u251c\u2500\u2500 hitl_iris.world\n    \u251c\u2500\u2500 hitl_standard_vtol.world\n    \u251c\u2500\u2500 iris_irlock.world\n    \u251c\u2500\u2500 ksql_airport.world\n    \u251c\u2500\u2500 mcmillan_airfield.world\n    \u251c\u2500\u2500 ocean.world\n    \u251c\u2500\u2500 sonoma_raceway.world\n    \u251c\u2500\u2500 typhoon_h480.world\n    \u251c\u2500\u2500 uuv_bluerov2_heavy.world\n    \u251c\u2500\u2500 uuv_hippocampus.world\n    \u251c\u2500\u2500 warehouse.world\n    \u251c\u2500\u2500 windy.world\n    \u2514\u2500\u2500 yosemite.world\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#drone_launch","title":"drone_launch","text":"<p>The <code>drone_launch</code> package contains several launch files that are used to run simulations and to run missions with the real drone.</p> <pre><code>src/drone_launch/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 real_bringup_rviz.launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 rvizcfg.rviz\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 simulator_bringup.launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 simulator_bringup_rviz.launch\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 single_vehicle_spawn.launch\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 vehicle_bringup.launch\n\u2514\u2500\u2500 package.xml\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#drone_gimmicks_library","title":"drone_gimmicks_library","text":"<p>The <code>drone_gimmicks_library</code> package contains some useful macros to reduce the complexity of some common ROS operations like getting parameters.</p> <pre><code>src/drone_library/drone_gimmicks_library/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_gimmicks_library\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 DroneGimmicks.h\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 DroneGimmicks.cpp\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#drone_utils_cpp","title":"drone_utils_cpp","text":"<p>The <code>drone_utils_cpp</code> package contains some useful functions while working with drones, like converting between different coordinate frames and normalizing thrust values.</p> <pre><code>src/drone_library/drone_utils_cpp/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 doc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 drone_utils_cpp\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 DroneInfo.h\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 DroneStatus.h\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 Utils.h\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 Utils.cpp\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#mavros_cpp","title":"mavros_cpp","text":"<p>The <code>mavros_cpp</code> package contains the main class (UAV) which is used to control the drone as well as to get telemetry data.</p> <pre><code>src/drone_library/mavros_cpp/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 doc\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 README.md\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 mavros_cpp\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 Actuators.h\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 EKF.h\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 Sensors.h\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 UAV.h\n\u251c\u2500\u2500 package.xml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 offboard.cpp\n    \u251c\u2500\u2500 telemetry.cpp\n    \u2514\u2500\u2500 UAV.cpp\n</code></pre>"},{"location":"Software%20Setup%20V11/drone_control_stack/#simulation-example","title":"Simulation example","text":"<p>After installing the code stack the provided lissajous example package can be executed in simulation. The <code>drone_sim.launch</code> file in the <code>drone_bringup</code> package should contain a call to the <code>lissajous</code> ROS node like so - <code>&lt;node pkg=\"lissajous\" type=\"lissajous_node\" name=\"lissajous\" respawn=\"false\" output=\"screen\"/&gt;</code>.</p> <ol> <li> <p>Build the workspace     <pre><code>cd ~/uav/uav_ws\ncatkin_make\n</code></pre></p> </li> <li> <p>Source the provided bash script     <pre><code>cd ~/uav\nsource setup.bash\n</code></pre></p> </li> <li> <p>Run the simulation     <pre><code>roslaunch drone_launch simulator_bringup.launch\n</code></pre></p> <p></p> </li> </ol>"},{"location":"Software%20Setup%20V11/os_installation/","title":"OS Installation and Setup","text":"<p>This guide provides installation instructions for the JetPack software which is used as an OS for the onboard computer. The following steps describe how to install the version 5.1.1 of JetPack on the onboard computer.  </p>"},{"location":"Software%20Setup%20V11/os_installation/#1-sdk-manager","title":"1. SDK Manager","text":"<p>The installation of the operating system should be made using the NVIDIA SDK Manager running on a computer with Ubuntu 18.04 or Ubuntu 20.04. For reference, the installation was made using a machine with Ubuntu 18.04 and the SDK Manager version 1.9.1.10899. This will allow us to install the OS onto an NVME SSD instead of using a micro-SD card.</p>"},{"location":"Software%20Setup%20V11/os_installation/#2-os-installation","title":"2. OS Installation","text":"<p>The SDK Manager can then be used to flash the JetPack 5.1.1 (rev. 1) OS onto the board as shown in the following images. Before flashing there is an option to select which storage solution to use for the OS as well as the ability to configure a user so as not to require a physical connection to the board on first boot to finish the OS installation.</p> <p> </p>"},{"location":"Software%20Setup%20V11/os_installation/#3-initial-setup","title":"3. Initial Setup","text":"<p>After the first boot it is recommended to update the installed packages and also to install some usefull additional packages:</p> <pre><code>sudo apt update\nsudo apt upgrade\nsudo apt install nano tmux python3-pip\n</code></pre> <p>Following that, jtop can be installed using pip. jtop is a tool that shows detailded stats and information about the nvidia board where it is running:</p> <pre><code>sudo pip3 install -U jetson-stats\n</code></pre>"},{"location":"Software%20Setup%20V11/os_installation/#4-compiling-opencv","title":"4. Compiling OpenCV","text":"<p>Even though OpenCV comes installed with the JetPack OS, it does not take advantage of the GPU. To solve this, the script from mdegans was used and the version 4.6.0 of OpenCV can be installed:</p> <pre><code>git clone https://github.com/mdegans/nano_build_opencv.git\ncd nano_build_opencv\nchmod +x build_opencv.sh\n./build_opencv.sh 4.6.0\n</code></pre> <p>Note</p> <p>This process takes a while. On the NVIDIA Jetson Orin Nano it takes approximately 2 hours.</p>"},{"location":"Software%20Setup%20V11/px4_configuration_checklist/","title":"PX4 Configuration Checklist","text":"<p>After assembling the vehicle, the PX4  autopilot running on the flight computer must be configured. Here is a general checklist of what needs to be done before the first flight. All of these configurations can be done using the QGroundControl application. It should be noted that this checklist is based on the PX4 documentation and more detailed instructions are available there.</p> <ol> <li>Sensor orientation on vehicle;</li> <li>Compass calibration;</li> <li>Gyroscope calibration;</li> <li>Accelerometer calibration;</li> <li>Radio setup (button mapping and calibration);</li> <li>Flight mode configuration (map radio button for manual/offboard mode change and safety hold/kill switch button);</li> <li>Battery (configure battery parameters for charge estimation);</li> <li>Configure failsafes;</li> <li>Actuators (configure geometry of motors and verify correct direction of spinning);</li> </ol> <p>After this process the vehicle should be ready for manual flight and it is now a good idea to check if the PID controllers' gains need to be adjusted.</p>"},{"location":"Software%20Setup%20V11/ros_installation/","title":"ROS Installation","text":"<p>The version of the installed OS is based on Ubuntu 20.04 for which the latest version of ROS1 is ROS Noetic. To install it, the official guide in the ROS wiki was followed.</p> <ol> <li> <p>Setup sources.list     <pre><code>sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list'\n</code></pre></p> </li> <li> <p>Setup keys     <pre><code>sudo apt install curl\ncurl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -\nsudo apt update\n</code></pre></p> </li> <li> <p>Installation (the desktop-full variant was selected for this specific installation)     <pre><code>sudo apt install ros-noetic-desktop-full\n</code></pre></p> </li> <li> <p>Environment setup     <pre><code>echo \"source /opt/ros/noetic/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre></p> </li> <li> <p>Dependencies for building packages     <pre><code>sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential\n\nsudo rosdep init\nrosdep update\n</code></pre></p> </li> </ol>"},{"location":"Software%20Setup%20V11/ros_installation/#mavros","title":"MAVROS","text":"<p>To communicate with the flight computer (running the PX4 autopilot) using the MAVLink protocol through ROS, the MAVROS package was used. It is assumed that the flight computer is connected to the onboard computer through USB.</p> <pre><code>sudo apt install ros-noetic-mavros\nsudo apt install ros-noetic-mavros-extras\ncd /opt/ros/noetic/lib/mavros\nsudo ./install_geographiclib_datasets.sh \n</code></pre> <p>Additionally, to allow access to the USB ports for serial communication with the flight computer, these commands are needed:</p> <pre><code>sudo gpasswd -a $USER dialout\nsudo reboot now\n</code></pre> <p>The package can now be tested by running <code>roslaunch mavros px4.launch</code> and verifying that data is being published in the available ROS topics (<code>rostopic list</code> and <code>rostopic echo ...</code>).</p> <p>The MAVROS package also allows to redirect the MAVLink communications to another computer, where QGroundControl can be used for example. To do this, an option can be included when calling the launch file - <code>roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@${GCS_IP}:${GCS_PORT}</code>, where fcu_url is where the flight computer is connected, GCS_IP is the IP of the computer that wants to access the MAVLink communications and GCS_Port is an arbitrary port.</p>"},{"location":"Software%20Setup%20V11/ros_installation/#mavros-example","title":"MAVROS Example","text":"<ol> <li>Onboard computer IP: 192.168.1.126; </li> <li>Flight computer connected to onboard computer through USB (/dev/ttyACM0);</li> <li>Other computer IP: 192.168.1.118;</li> <li>Run <code>roslaunch mavros px4.launch fcu_url:=/dev/ttyACM0:57600 gcs_url:=udp://@192.168.1.118:15001</code> on the onboard computer;</li> <li>Run <code>roslaunch mavros px4.launch fcu_url:=udp://:15001@ gcs_url:=udp://@localhost:15002</code> on the other computer;</li> <li><code>rostopic list</code> and <code>rostopic echo ...</code> on the other computer will show the data from the flight computer;</li> <li>QGroundControl can be used on the other computer on port 15002.</li> </ol>"},{"location":"Software%20Setup%20V11/usefull_packages/","title":"Usefull Packages","text":"<p>In order to facilitate testing and operation of the drone, two ROS packages are provided.</p>"},{"location":"Software%20Setup%20V11/usefull_packages/#mav_tools","title":"mav_tools","text":"<p>The mav_tools ROS package runs on top of MAVROS to provide a GUI interface that can run on the terminal and is able to display information like the battery state and basic control of the drone, like changing flight mode and arming/disarming the vehicle.</p> <p></p>"},{"location":"Software%20Setup%20V11/usefull_packages/#test_comms_pixhawk","title":"test_comms_pixhawk","text":"<p>The test_comms_pixhawk package provides an easy way to test the communication from the ROS control stack to the pixhawk flight computer by logging telemetry data and arming and disarming the drone.</p>"},{"location":"Vehicle%20Setup/","title":"Vehicle Setup","text":"<p>This section documents in detail the entire vehicle setup, including all the hardware components that make up the vehicle as well as the entire software package that allows it to function. In this way, the section is divided into two main subsections:</p> <ul> <li>Hardware Setup - describes the main hardware components of the vehicle;</li> <li>Software Setup - describes the software used, including the installation processes.</li> </ul>"}]}